Sample aarch64 trace directory contents:
+ drmemtrace.threadsig.49768.5624.dir/trace/* == the trace itself, with a
  separate file per application thread.
+ drmemtrace.threadsig.49768.5624.dir/raw/modules.log == the list of libraries
  mapped into the application address space.
+ binaries/ == binaries for the librares listed in the modules.log file.
+ threadsig.cpp == the source code of the traced application.
+ README.txt == this file.

The memory address tracer we use is part of the "drcachesim" open-source
tool [1], which is part of the DynamoRIO dynamic binary instrumentation
framework [2].

The trace format used by analysis tools is the memref_t structure [3].  A
simple analysis tool to look at is basic_counts.cpp [4].

A low-level textual view of the sample trace:
--------------------------------------------------
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -verbose 3 2>&1 | less
  ::49768.49768:: marker type 2 value 13260902406616557
  ::49768.49768:: marker type 3 value 42
  new thread 49768 => core 0 (count=0)
  ::49768.49768::  @0x400678 instr x4
  ::49768.49768::  @0x40067c instr x4
  ::49768.49768::  @0x400680 instr x4
  ::49768.49768::  @0x400684 instr x4
  ::49768.49768::  @0x400684 read 0xfffffe05ecc0 x8
  ::49768.49768::  @0x400688 instr x4
  <...>
  ::49768.49768::  @0x42d170 instr x4
  ::49768.49768::  @0x42d174 instr x4
  ::49768.49768::  @0x42d178 instr x4
  ::49768.49769:: marker type 2 value 13260902407398488
  ::49768.49769:: marker type 3 value 50
  ::49768.49769:: marker type 0 value 189040
  ::49768.49769:: marker type 2 value 13260902407398716
  ::49768.49769:: marker type 3 value 50
  new thread 49769 => core 1 (count=0)
  ::49768.49769::  @0x4008d8 instr x4
  ::49768.49769::  @0x4008dc instr x4
  ::49768.49769::  @0x4008e0 instr x4
  ::49768.49769::  @0x4008e4 instr x4
  ::49768.49769::  @0x4008e8 instr x4
  ::49768.49769::  @0x4008e8 read 0x4a7ab8 x4
  ::49768.49769::  @0x4008ec instr x4
  ::49768.49769::  @0x4008f0 instr x4
  ::49768.49769::  @0x4008f0 write 0x4a7ab8 x4
  <...>
--------------------------------------------------

It is a series of instruction fetch, data fetch, and metadata entries.  The
fetches contain addresses and sizes ("x4" is a size in the verbose
listing).  The addresses are all virtual.  The metadata
"markers" indicate things like which core a thread executed on, timestamps,
an arriving signal causing a PC discontinuity, etc.

For using a trace in a core simulator, you will want to obtain the opcodes.
These are not part of the base trace.  They are obtained by decoding the
instruction fetch addresses from the binaries.  Library support makes this
straightforward.  A sample tool that does this is opcode_mix.cpp [5].  It
uses library routines to read the "modules.log" file, which contains the
mappings of the binary and libraries from the traced execution, and map
those binaries into the address space, allowing examining the instruction
bytes.  The modules.log file is included here, along with all of the
binaries referenced there.  For the vdso the raw bytes are embedded in the
file and mapped in just like the binaries.

Other aspects of the trace which help core simulation are discussed in our
documentation [6].

The sample trace here is small but includes corner cases of thread
interleavings, signals, and "non-fetched" instructions.  The trace is from
the "threadsig" application whose source code is included.  It is an
adaptation of [7] with extra threads, signals, and string loop
instructions.

The trace was generated by running:
  $ bin64/drrun -t drcachesim -offline -- ./threadsig 20 200000

Counts of event types in the trace:
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -simulator_type basic_counts
  Basic counts tool results:                                                       
  Total counts:                                                                    
      10651975 total (fetched) instructions
          6399 total unique (fetched) instructions
             0 total non-fetched instructions
            39 total prefetches
        210300 total data loads
       2207422 total data stores
             0 total icache flushes
             0 total dcache flushes
            21 total threads
          3436 total scheduling markers
           484 total transfer markers
             0 total function id markers
             0 total function return address markers
             0 total function argument markers
             0 total function return value markers
            42 total other markers
  Thread 49770 counts:
        530374 (fetched) instructions
           375 unique (fetched) instructions
  <...>

Top opcodes in the trace:
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -simulator_type opcode_mix -module_file drmemtrace*.dir/raw/modules.log
  Opcode mix tool results:
         10651975 : total executed instructions
          1404641 :     bcond
          1403183 :       stp
          1203860 :      subs
          1006120 :       add
           800679 :       and
           600116 :        xx
           403529 :       str
           401986 :      movz
  <...>

The "xx" is part of a set of opcodes not yet added to the decoder [8].

You can run any of the commands above yourself by downloading DynamoRIO
[9].

References from above:

[1] = http://dynamorio.org/page_drcachesim.html
[1] = http://dynamorio.org
[3] = http://dynamorio.org/union__memref__t.html
(source: https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/common/memref.h)
[4] = https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/tools/basic_counts.cpp
[5] = https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/tools/opcode_mix.cpp
[6] = https://dynamorio.org/sec_drcachesim_core.html
[7] = https://github.com/DynamoRIO/dynamorio/blob/master/suite/tests/pthreads/ptsig.c
[8] = https://github.com/DynamoRIO/dynamorio/issues/2626
[9] = https://github.com/DynamoRIO/dynamorio/releases/latest
