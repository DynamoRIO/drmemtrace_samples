Sample aarch64 trace directory contents:
+ drmemtrace.threadsig.11451.1365.dir/trace/* == the trace itself, with a
  separate file per application thread.
+ drmemtrace.threadsig.11451.1365.dir/raw/modules.log == the list of libraries
  mapped into the application address space.
+ binaries/ == binaries for the librares listed in the modules.log file.
+ threadsig.cpp == the source code of the traced application.
+ README.txt == this file.

The memory address tracer we use is part of the "drcachesim" open-source
tool [1], which is part of the DynamoRIO dynamic binary instrumentation
framework [2].

The trace format used by analysis tools is the memref_t structure [3].  A
simple analysis tool to look at is basic_counts.cpp [4].

A low-level textual view of the sample trace:
--------------------------------------------------
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -verbose 3 2>&1 | less
  ::11451.11451:: marker type 2 value 13236734289995944
  ::11451.11451:: marker type 3 value 90
  new thread 11451 => core 0 (count=0)
  ::11451.11451::  @0x400940 instr x4
  ::11451.11451::  @0x400944 instr x4
  ::11451.11451::  @0x400948 instr x4
  ::11451.11451::  @0x40094c instr x4
  ::11451.11451::  @0x40094c read 0xfffff9b9b950 x8
  ::11451.11451::  @0x400950 instr x4
  ::11451.11451::  @0x400954 instr x4
  <...>
  ::11451.11451::  @0x4bf3c8 instr x4
  ::11451.11451::  @0x4bf3cc instr x4
  ::11451.11452:: marker type 2 value 13236734290148766
  ::11451.11452:: marker type 3 value 8
  new thread 11452 => core 1 (count=0)
  ::11451.11452::  @0x4bf3d0 instr x4
  ::11451.11452::  @0x4bf3d4 instr x4
  ::11451.11452:: marker type 0 value 783344
  ::11451.11452:: marker type 2 value 13236734290148930
  ::11451.11452:: marker type 3 value 8
  ::11451.11452::  @0x400ad0 instr x4
  ::11451.11452::  @0x400ad4 instr x4
  ::11451.11452::  @0x400ad4 write 0xffff09cb96fc x4
  ::11451.11452::  @0x400ad8 instr x4
  ::11451.11452::  @0x400ad8 write 0xffff09cb96f0 x8
  <...>
--------------------------------------------------

It is a series of instruction fetch, data fetch, and metadata entries.  The
fetches contain addresses and sizes ("x4" is a size in the verbose
listing).  The addresses are all virtual.  The metadata
"markers" indicate things like which core a thread executed on, timestamps,
an arriving signal causing a PC discontinuity, etc.

For using a trace in a core simulator, you will want to obtain the opcodes.
These are not part of the base trace.  They are obtained by decoding the
instruction fetch addresses from the binaries.  Library support makes this
straightforward.  A sample tool that does this is opcode_mix.cpp [5].  It
uses library routines to read the "modules.log" file, which contains the
mappings of the binary and libraries from the traced execution, and map
those binaries into the address space, allowing examining the instruction
bytes.  The modules.log file is included here, along with all of the
binaries referenced there.  For the vdso the raw bytes are embedded in the
file and mapped in just like the binaries.

Other aspects of the trace which help core simulation are discussed in our
documentation [6].

The sample trace here is small but includes corner cases of thread
interleavings, signals, and "non-fetched" instructions.  The trace is from
the "threadsig" application whose source code is included.  It is an
adaptation of [7] with extra threads, signals, and string loop
instructions.

The trace was generated by running:
  $ bin64/drrun -t drcachesim -offline -- ./threadsig 20 200000

Counts of event types in the trace:
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -simulator_type basic_counts
      33456786 total (fetched) instructions
          7341 total unique (fetched) instructions
             0 total non-fetched instructions
             0 total prefetches
       7812346 total data loads
       8608666 total data stores
            21 total threads
          6128 total scheduling markers
           136 total transfer markers
             0 total function id markers
             0 total function return address markers
             0 total function argument markers
             0 total function return value markers
             0 total other markers
  Thread 11452 counts:
       1670477 (fetched) instructions
           460 unique (fetched) instructions
  <...>

Top opcodes in the trace:
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -simulator_type opcode_mix -module_file drmemtrace*.dir/raw/modules.log
  Opcode mix tool results:
         33456786 : total executed instructions
          8003446 :       stp
          6602749 :       ldp
          3404095 :     bcond
          3203896 :      subs
          2806802 :       add
          1400139 :        xx
          1200730 :       and
          1007981 :       ldr
  <...>

The "xx" is part of a set of opcodes not yet added to the decoder [8].

You can run any of the commands above yourself by downloading DynamoRIO
[9].

References from above:

[1] = http://dynamorio.org/dynamorio_docs/page_drcachesim.html
[1] = http://dynamorio.org
[3] = http://dynamorio.org/dynamorio_docs/union__memref__t.html
(source: https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/common/memref.h)
[4] = https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/tools/basic_counts.cpp
[5] = https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/tools/opcode_mix.cpp
[6] = http://dynamorio.org/dynamorio_docs/page_drcachesim.html#sec_drcachesim_core
[7] = https://github.com/DynamoRIO/dynamorio/blob/master/suite/tests/pthreads/ptsig.c
[8] = https://github.com/DynamoRIO/dynamorio/issues/2626
[9] = https://github.com/DynamoRIO/dynamorio/releases/latest
