Sample x86_64 trace directory contents:
+ drmemtrace.threadsig.342625.4446.dir/trace/* == the trace itself, with a
  separate file per application thread.
+ drmemtrace.threadsig.342625.4446.dir/raw/modules.log == the list of libraries
  mapped into the application address space.
+ binaries/ == binaries for the librares listed in the modules.log file.
+ threadsig.cpp == the source code of the traced application.
+ README.txt == this file.

The memory address tracer we use is part of the "drcachesim" open-source
tool [1], which is part of the DynamoRIO dynamic binary instrumentation
framework [2].

The trace format used by analysis tools is the memref_t structure [3].  A
simple analysis tool to look at is basic_counts.cpp [4].

A low-level textual view of the sample trace:
--------------------------------------------------
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -verbose 3 2>&1 | less
  ::342625.342625:: marker type 2 value 13260900247983768
  ::342625.342625:: marker type 3 value 3
  new thread 342625 => core 0 (count=0)
  ::342625.342625::  @0x402460 instr x2
  ::342625.342625::  @0x402462 instr x3
  ::342625.342625::  @0x402465 instr x1
  ::342625.342625::  @0x402465 read 0x7ffe70dce480 x8
  ::342625.342625::  @0x402466 instr x3
  <...>
  ::342625.342625::  @0x467c4a instr x5
  ::342625.342625::  @0x467c4f instr x2
  ::342625.342626:: marker type 2 value 13260900248221723
  ::342625.342626:: marker type 3 value 0
  new thread 342626 => core 1 (count=0)
  ::342625.342626::  @0x467c51 instr x3
  ::342625.342626::  @0x467c54 instr x2
  ::342625.342626::  @0x467c56 instr x2
  ::342625.342626::  @0x467c59 instr x2
  ::342625.342626::  @0x467c5b instr x1
  ::342625.342626::  @0x467c5b read 0x7f899f928e70 x8
  ::342625.342626::  @0x467c5c instr x1
  ::342625.342626::  @0x467c5c read 0x7f899f928e78 x8
  ::342625.342626::  @0x467c5d instr x2
  ::342625.342626::  @0x467c5d write 0x7f899f928e78 x8
  <...>
--------------------------------------------------

It is a series of instruction fetch, data fetch, and metadata entries.  The
fetches contain addresses and sizes ("x3" is a size in the verbose
listing).  The addresses are all virtual.  The metadata
"markers" indicate things like which core a thread executed on, timestamps,
an arriving signal causing a PC discontinuity, etc.

For using a trace in a core simulator, you will want to obtain the opcodes.
These are not part of the base trace.  They are obtained by decoding the
instruction fetch addresses from the binaries.  Library support makes this
straightforward.  A sample tool that does this is opcode_mix.cpp [5].  It
uses library routines to read the "modules.log" file, which contains the
mappings of the binary and libraries from the traced execution, and map
those binaries into the address space, allowing examining the instruction
bytes.  The modules.log file is included here, along with all of the
binaries referenced there.  For the vdso the raw bytes are embedded in the
file and mapped in just like the binaries.

Other aspects of the trace which help core simulation are discussed in our
documentation [6].

The sample trace here is small but includes corner cases of thread
interleavings, signals, and "non-fetched" instructions.  The trace is from
the "threadsig" application whose source code is included.  It is an
adaptation of [7] with extra threads, signals, and string loop
instructions.

The trace was generated by running:
  $ bin64/drrun -t drcachesim -offline -- ./threadsig 20 200000

Counts of event types in the trace:
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -simulator_type basic_counts
  Basic counts tool results:                                                       
  Total counts:                                                                    
      15892162 total (fetched) instructions
          8925 total unique (fetched) instructions
      12600073 total non-fetched instructions
             0 total prefetches
      15221284 total data loads
      17411564 total data stores
             0 total icache flushes
             0 total dcache flushes
            21 total threads
         22038 total scheduling markers
           108 total transfer markers
             0 total function id markers
             0 total function return address markers
             0 total function argument markers
             0 total function return value markers
            42 total other markers
  Thread 342626 counts:
        790377 (fetched) instructions
           346 unique (fetched) instructions
  <...>

Top opcodes in the trace:
  $ bin64/drrun -t drcachesim -indir drmemtrace*.dir -simulator_type opcode_mix -module_file drmemtrace*.dir/raw/modules.log
  Opcode mix tool results:
         28492235 : total executed instructions
         12800000 :  rep movs
          2400137 :   vmovdqa
          1609991 :       cmp
          1600378 :   vmovdqu
          1007478 :       add
          1000184 :     movsd
  <...>

You can run any of the commands above yourself by downloading DynamoRIO
[8].

References from above:

[1] = http://dynamorio.org/page_drcachesim.html
[1] = http://dynamorio.org
[3] = http://dynamorio.org/union__memref__t.html
(source: https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/common/memref.h)
[4] = https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/tools/basic_counts.cpp
[5] = https://github.com/DynamoRIO/dynamorio/blob/master/clients/drcachesim/tools/opcode_mix.cpp
[6] = https://dynamorio.org/sec_drcachesim_core.html
[7] = https://github.com/DynamoRIO/dynamorio/blob/master/suite/tests/pthreads/ptsig.c
[8] = https://github.com/DynamoRIO/dynamorio/releases/latest
